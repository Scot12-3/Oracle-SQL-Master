# PL/SQL Examples â€” One sample per common construct

This file contains short, runnable PL/SQL examples for common PL/SQL program units and features. Paste these into SQL*Plus, SQLcl, or Oracle SQL Developer and run.

Notes:

- Many examples use a classic `emp` table (EMP/DEPT). If you don't have that schema, replace `emp` with your table names.
- In SQL*Plus / SQLcl: run `SET SERVEROUTPUT ON SIZE UNLIMITED` to see DBMS_OUTPUT; in SQL Developer enable DBMS_OUTPUT.

---

## 1) Anonymous block (ad-hoc logic)

```sql
BEGIN
  DBMS_OUTPUT.ENABLE;
  DBMS_OUTPUT.PUT_LINE('Hello from an anonymous PL/SQL block');
END;
/
```

---

## 2) Simple procedure

```sql
CREATE OR REPLACE PROCEDURE greet(p_name IN VARCHAR2) AS
BEGIN
  DBMS_OUTPUT.PUT_LINE('Hello, ' || p_name || '!');
END greet;
/

-- Call it:
BEGIN
  greet('Alice');
END;
/
```

---

## 3) Function to get employee count

```sql
CREATE OR REPLACE FUNCTION get_emp_count(p_deptno IN NUMBER) RETURN NUMBER IS
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM emp WHERE deptno = p_deptno;
  RETURN v_count;
END get_emp_count;
/

-- Usage:
DECLARE
  n NUMBER;
BEGIN
  n := get_emp_count(10);
  DBMS_OUTPUT.PUT_LINE('Employees in dept 10: ' || n);
END;
/
```

---

## 4) Package (spec + body) with a public procedure and private helper

```sql
CREATE OR REPLACE PACKAGE emp_utils AS
  PROCEDURE give_raise(p_deptno IN NUMBER, p_pct IN NUMBER);
END emp_utils;
/

CREATE OR REPLACE PACKAGE BODY emp_utils AS
  PROCEDURE log_change(p_empno NUMBER, p_old_sal NUMBER, p_new_sal NUMBER) IS
  BEGIN
    INSERT INTO emp_audit(empno, action, action_date) VALUES(p_empno, 'SAL-UPDATE', SYSDATE);
  END log_change;

  PROCEDURE give_raise(p_deptno IN NUMBER, p_pct IN NUMBER) IS
  BEGIN
    FOR r IN (SELECT empno, sal FROM emp WHERE deptno = p_deptno) LOOP
      UPDATE emp SET sal = ROUND(r.sal * (1 + p_pct/100), 2) WHERE empno = r.empno;
      log_change(r.empno, r.sal, ROUND(r.sal * (1 + p_pct/100), 2));
    END LOOP;
    COMMIT;
  END give_raise;
END emp_utils;
/

-- Use it:
BEGIN
  emp_utils.give_raise(10, 5);
END;
/
```

---

## 5) Row-level trigger (audit on emp)

```sql
CREATE TABLE emp_audit (
  id       NUMBER GENERATED BY DEFAULT AS IDENTITY,
  empno    NUMBER,
  action   VARCHAR2(20),
  action_ts TIMESTAMP DEFAULT SYSTIMESTAMP
);
/

CREATE OR REPLACE TRIGGER trg_emp_audit
AFTER INSERT OR UPDATE OR DELETE ON emp
FOR EACH ROW
BEGIN
  IF INSERTING THEN
    INSERT INTO emp_audit(empno, action) VALUES(:NEW.empno, 'INSERT');
  ELSIF UPDATING THEN
    INSERT INTO emp_audit(empno, action) VALUES(:NEW.empno, 'UPDATE');
  ELSIF DELETING THEN
    INSERT INTO emp_audit(empno, action) VALUES(:OLD.empno, 'DELETE');
  END IF;
END;
/
```

---

## 6) Statement-level trigger (audit DML statement)

```sql
-- Statement-level triggers run once per statement (not per row).
CREATE OR REPLACE TRIGGER trg_emp_stmt
AFTER INSERT OR UPDATE OR DELETE ON emp
BEGIN
  INSERT INTO emp_audit(empno, action)
  VALUES(NULL, 'EMP_TABLE_MODIFIED');
END;
/
```

---

## 7) Explicit cursor and cursor loop

```sql
DECLARE
  CURSOR c IS SELECT empno, ename, sal FROM emp WHERE deptno = 10;
  r c%ROWTYPE;
BEGIN
  OPEN c;
  LOOP
    FETCH c INTO r;
    EXIT WHEN c%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(r.empno || ' - ' || r.ename || ' : ' || r.sal);
  END LOOP;
  CLOSE c;
END;
/
```

---

## 8) Cursor FOR loop (implicit open/fetch/close)

```sql
BEGIN
  FOR r IN (SELECT empno, ename FROM emp WHERE deptno = 20) LOOP
    DBMS_OUTPUT.PUT_LINE(r.empno || ' - ' || r.ename);
  END LOOP;
END;
/
```

---

## 9) REF CURSOR (returned from function)

```sql
CREATE OR REPLACE FUNCTION open_emp_refcur(p_deptno IN NUMBER) RETURN SYS_REFCURSOR IS
  l_rc SYS_REFCURSOR;
BEGIN
  OPEN l_rc FOR SELECT empno, ename, sal FROM emp WHERE deptno = p_deptno;
  RETURN l_rc;
END open_emp_refcur;
/

-- Consume it:
DECLARE
  c SYS_REFCURSOR;
  v_empno emp.empno%TYPE;
  v_ename emp.ename%TYPE;
  v_sal emp.sal%TYPE;
BEGIN
  c := open_emp_refcur(10);
  LOOP
    FETCH c INTO v_empno, v_ename, v_sal;
    EXIT WHEN c%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(v_empno || ' | ' || v_ename || ' | ' || v_sal);
  END LOOP;
  CLOSE c;
END;
/
```

---

## 10) Collections: associative array example

```sql
DECLARE
  TYPE t_empno_tab IS TABLE OF emp.empno%TYPE INDEX BY PLS_INTEGER;
  l_tab t_empno_tab;
BEGIN
  l_tab(1) := 7369;
  l_tab(2) := 7499;
  DBMS_OUTPUT.PUT_LINE('First empno: ' || l_tab(1));
END;
/
```

---

## 11) Nested table + TABLE() usage (pipelined)

```sql
-- create a nested table type and a function returning a collection
CREATE OR REPLACE TYPE tt_empnos AS TABLE OF NUMBER;
/

CREATE OR REPLACE FUNCTION get_empnos_by_dept(p_deptno IN NUMBER) RETURN tt_empnos PIPELINED IS
BEGIN
  FOR r IN (SELECT empno FROM emp WHERE deptno = p_deptno) LOOP
    PIPE ROW(r.empno);
  END LOOP;
  RETURN;
END get_empnos_by_dept;
/

-- Query the pipelined function
SELECT * FROM TABLE(get_empnos_by_dept(10));
```

---

## 12) BULK COLLECT and FORALL (fast bulk processing)

```sql
DECLARE
  TYPE t_empno_tab IS TABLE OF emp.empno%TYPE;
  l_empnos t_empno_tab;
BEGIN
  SELECT empno BULK COLLECT INTO l_empnos FROM emp WHERE deptno = 10;

  FORALL i IN 1 .. l_empnos.COUNT
    UPDATE emp SET sal = sal * 1.10 WHERE empno = l_empnos(i);

  COMMIT;
END;
/
```

---

## 13) Dynamic SQL (EXECUTE IMMEDIATE)

```sql
DECLARE
  l_sql VARCHAR2(4000);
  l_count NUMBER;
BEGIN
  l_sql := 'SELECT COUNT(*) FROM emp WHERE deptno = :1';
  EXECUTE IMMEDIATE l_sql INTO l_count USING 10;
  DBMS_OUTPUT.PUT_LINE('Count: ' || l_count);
END;
/
```

---

## 14) Autonomous transaction (logging from within main transaction)

```sql
CREATE OR REPLACE PROCEDURE log_message(p_msg VARCHAR2) IS
  PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
  INSERT INTO emp_audit(empno, action, action_ts) VALUES(NULL, p_msg, SYSTIMESTAMP);
  COMMIT; -- must commit in autonomous transaction
END log_message;
/

-- Use it in a block without committing the main transaction:
BEGIN
  INSERT INTO emp(empno, ename, sal, deptno) VALUES(9999, 'TMP', 0, 99);
  log_message('Inserted TMP row 9999');
  ROLLBACK; -- main transaction rollback does not remove autonomous log
END;
/
```

---

## 15) Exception handling with user-defined exception

```sql
DECLARE
  e_too_many EXCEPTION;
  PRAGMA EXCEPTION_INIT(e_too_many, -20001);
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM emp;
  IF v_count > 10000 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Too many employees to process');
  END IF;
EXCEPTION
  WHEN e_too_many THEN
    DBMS_OUTPUT.PUT_LINE('Application error: ' || SQLERRM);
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Unexpected: ' || SQLERRM);
END;
/
```

---

## 16) Pipelined table function (returns rows progressively)

```sql
-- reuse the tt_empnos type created earlier
CREATE OR REPLACE FUNCTION pipelined_emp_by_dept(p_deptno IN NUMBER) RETURN tt_empnos PIPELINED IS
BEGIN
  FOR r IN (SELECT empno FROM emp WHERE deptno = p_deptno) LOOP
    PIPE ROW(r.empno);
  END LOOP;
  RETURN;
END pipelined_emp_by_dept;
/

-- Query:
SELECT * FROM TABLE(pipelined_emp_by_dept(10));
```

---

## 17) Simple object type and table of objects (brief example)

```sql
CREATE OR REPLACE TYPE t_emp_obj AS OBJECT(
  empno NUMBER,
  ename VARCHAR2(50)
);
/

CREATE OR REPLACE TYPE t_emp_obj_tab AS TABLE OF t_emp_obj;
/
DECLARE
  l_tab t_emp_obj_tab := t_emp_obj_tab();
BEGIN
  l_tab.EXTEND;
  l_tab(l_tab.COUNT) := t_emp_obj(7369, 'SMITH');
  DBMS_OUTPUT.PUT_LINE('Obj count: ' || l_tab.COUNT);
END;
/
```

---

## 18) Small example: Using DBMS_SQL for dynamic SQL with unknown columns (advanced)

```sql
DECLARE
  cur INTEGER;
  rc INTEGER;
  colcnt INTEGER;
BEGIN
  cur := DBMS_SQL.OPEN_CURSOR;
  DBMS_SQL.PARSE(cur, 'SELECT empno, ename FROM emp WHERE ROWNUM = 1', DBMS_SQL.NATIVE);
  rc := DBMS_SQL.EXECUTE(cur);
  DBMS_SQL.CLOSE_CURSOR(cur);
  DBMS_OUTPUT.PUT_LINE('DBMS_SQL executed');
EXCEPTION
  WHEN OTHERS THEN
    IF DBMS_SQL.IS_OPEN(cur) THEN
      DBMS_SQL.CLOSE_CURSOR(cur);
    END IF;
    RAISE;
END;
/
```

---

End of examples. Replace `emp` references if your schema differs.
